<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nautypp: nautypp::Nauty Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Nautypp
   &#160;<span id="projectnumber">0.2</span>
   </div>
   <div id="projectbrief">NautyPP is a wrapper for nauty in multithreaded C++ context</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenautypp.html">nautypp</a></li><li class="navelem"><a class="el" href="classnautypp_1_1Nauty.html">Nauty</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classnautypp_1_1Nauty-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">nautypp::Nauty Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Wrapper for geng/gentreeg.  
 <a href="classnautypp_1_1Nauty.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="nauty_8hpp_source.html">nauty.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5c8e134437462fe28e3c688f9e0af163"><td class="memTemplParams" colspan="2">template&lt;GraphFunctionType GraphFunction&gt; </td></tr>
<tr class="memitem:a5c8e134437462fe28e3c688f9e0af163"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnautypp_1_1Nauty.html#a5c8e134437462fe28e3c688f9e0af163">run_async</a> (GraphFunction callback, FILE *f, size_t max_graph_size=100, size_t nb_workers=std::thread::hardware_concurrency(), size_t worker_buffer_size=5 '000)</td></tr>
<tr class="memdesc:a5c8e134437462fe28e3c688f9e0af163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run some callback on all graphs found in a file.  <a href="classnautypp_1_1Nauty.html#a5c8e134437462fe28e3c688f9e0af163">More...</a><br /></td></tr>
<tr class="separator:a5c8e134437462fe28e3c688f9e0af163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffe78c2e8d9d11ffdcbfd475e6a3240"><td class="memTemplParams" colspan="2">template&lt;GraphFunctionType GraphFunction&gt; </td></tr>
<tr class="memitem:adffe78c2e8d9d11ffdcbfd475e6a3240"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnautypp_1_1Nauty.html#adffe78c2e8d9d11ffdcbfd475e6a3240">run_async</a> (GraphFunction callback, const std::string &amp;file_path, size_t max_graph_size=100, size_t nb_workers=std::thread::hardware_concurrency(), size_t worker_buffer_size=5 '000)</td></tr>
<tr class="memdesc:adffe78c2e8d9d11ffdcbfd475e6a3240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run some callback on all graphs found in a file.  <a href="classnautypp_1_1Nauty.html#adffe78c2e8d9d11ffdcbfd475e6a3240">More...</a><br /></td></tr>
<tr class="separator:adffe78c2e8d9d11ffdcbfd475e6a3240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2c9112df331005c491c0d68d9404a5"><td class="memTemplParams" colspan="2">template&lt;GraphFunctionType GraphFunction&gt; </td></tr>
<tr class="memitem:a4e2c9112df331005c491c0d68d9404a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnautypp_1_1Nauty.html#a4e2c9112df331005c491c0d68d9404a5">run_async</a> (GraphFunction callback, const <a class="el" href="structnautypp_1_1NautyParameters.html">NautyParameters</a> &amp;parameters, size_t nb_workers=std::thread::hardware_concurrency(), size_t worker_buffer_size=5 '000)</td></tr>
<tr class="memdesc:a4e2c9112df331005c491c0d68d9404a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run some callback on all graphs generated by geng/gentreeg.  <a href="classnautypp_1_1Nauty.html#a4e2c9112df331005c491c0d68d9404a5">More...</a><br /></td></tr>
<tr class="separator:a4e2c9112df331005c491c0d68d9404a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02b695d9986932b6acbdc773c1432f2"><td class="memTemplParams" colspan="2">template&lt;GraphRefFunctionType Callback&gt; </td></tr>
<tr class="memitem:ac02b695d9986932b6acbdc773c1432f2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classnautypp_1_1Nauty.html#ac02b695d9986932b6acbdc773c1432f2">run_async</a> (const <a class="el" href="structnautypp_1_1NautyParameters.html">NautyParameters</a> &amp;parameters, size_t nb_workers=std::thread::hardware_concurrency(), size_t worker_buffer_size=5 '000) -&gt; typename Callback::ResultType</td></tr>
<tr class="separator:ac02b695d9986932b6acbdc773c1432f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa647ddb7dd1fc9179dc9baef93b3b04d"><td class="memItemLeft" align="right" valign="top"><a id="aa647ddb7dd1fc9179dc9baef93b3b04d"></a>
static std::unique_ptr&lt; <a class="el" href="classnautypp_1_1NautyContainer.html">NautyContainer</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_container</b> ()</td></tr>
<tr class="separator:aa647ddb7dd1fc9179dc9baef93b3b04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Wrapper for geng/gentreeg. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ac02b695d9986932b6acbdc773c1432f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02b695d9986932b6acbdc773c1432f2">&#9670;&nbsp;</a></span>run_async() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;GraphRefFunctionType Callback&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto nautypp::Nauty::run_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnautypp_1_1NautyParameters.html">NautyParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nb_workers</em> = <code>std::thread::hardware_concurrency()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>worker_buffer_size</em> = <code>5'000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; typename Callback::ResultType </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alternative version of run_async.</p>
<p>Here, the callback is not provided by reference but by type.</p>
<p>The template type <em>Callback</em> must:</p><ul>
<li>provide a type <code>Callback::ResultType</code></li>
<li>define <code>operator()(const Graph&amp;)</code></li>
<li>define <code>join(Callback&amp;&amp; other)</code></li>
<li>define <code>ResultType&amp;&amp; get()</code></li>
</ul>
<p><b>Example</b>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;nautypp/nautypp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacenautypp.html">nautypp</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> _max_independent_set(</div>
<div class="line">        <span class="keyword">const</span> Graph&amp; G, std::vector&lt;std::uint8_t&gt;&amp; taken,</div>
<div class="line">        <span class="keywordtype">size_t</span>&amp; current_size, <span class="keywordtype">size_t</span>&amp; max_size, Vertex v) {</div>
<div class="line">    <span class="keywordflow">if</span>(v == G.V()) {</div>
<div class="line">        <span class="keywordflow">if</span>(current_size &gt; max_size)</div>
<div class="line">            max_size = current_size;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordtype">bool</span> can_take_v{<span class="keyword">true</span>};</div>
<div class="line">        <span class="keywordflow">for</span>(Vertex w : G.neighbours_of(v)) {</div>
<div class="line">            <span class="keywordflow">if</span>(taken[w]) {</div>
<div class="line">                can_take_v = <span class="keyword">false</span>;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span>(can_take_v) {</div>
<div class="line">            taken[v] = <span class="keyword">true</span>;</div>
<div class="line">            ++current_size;</div>
<div class="line">            _max_independent_set(G, taken, current_size, max_size, v+1);</div>
<div class="line">            --current_size;</div>
<div class="line">            taken[v] = <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">        _max_independent_set(G, taken, current_size, max_size, v+1);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><span class="comment">// Compute the independence number of a graph</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">size_t</span> max_independent_set(<span class="keyword">const</span> Graph&amp; G) {</div>
<div class="line">    std::vector&lt;std::uint8_t&gt; taken(G.V(), <span class="keyword">false</span>);</div>
<div class="line">    <span class="keywordtype">size_t</span> current_size{0};</div>
<div class="line">    <span class="keywordtype">size_t</span> max_size{0};</div>
<div class="line">    _max_independent_set(G, taken, current_size, max_size, 0);</div>
<div class="line">    <span class="keywordflow">return</span> max_size;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Callback {</div>
<div class="line">    <span class="keyword">typedef</span> std::map&lt;Graph::DegreeDistribution, size_t&gt; ResultType;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Called on each graph generated by geng</span></div>
<div class="line">    <span class="keywordtype">void</span> operator()(Graph&amp; G) {</div>
<div class="line">        <span class="keywordtype">size_t</span> alpha{max_independent_set(G)};</div>
<div class="line">        <span class="keyword">auto</span> degdist{G.degree_distribution()};</div>
<div class="line">        <span class="keyword">auto</span> [it, inserted] = minima.try_emplace(std::move(degdist), alpha);</div>
<div class="line">        <span class="comment">// only keep the smallest independence number associated with this degree distribution</span></div>
<div class="line">        <span class="keywordflow">if</span>(not inserted and alpha &lt; it-&gt;second)</div>
<div class="line">            it-&gt;second = alpha;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// When every worker thread is done with its computations,</span></div>
<div class="line">    <span class="comment">// they are joined through this method</span></div>
<div class="line">    <span class="keywordtype">void</span> join(Callback&amp;&amp; other) {</div>
<div class="line">        minima.merge(other.minima);</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; [degdist, alpha] : other.minima) {</div>
<div class="line">            <span class="keyword">auto</span> it{minima.find(degdist)};</div>
<div class="line">            it-&gt;second = std::min(it-&gt;second, alpha);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// And once all the workers are joined, the final result is pooled from the last one</span></div>
<div class="line">    ResultType&amp;&amp; get() {</div>
<div class="line">        <span class="keywordflow">return</span> std::move(minima);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ResultType minima;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, <span class="keyword">const</span> std::vector&lt;std::pair&lt;size_t, size_t&gt;&gt;&amp; v) {</div>
<div class="line">    os &lt;&lt; <span class="stringliteral">&quot;{&quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i{0}; i &lt; v.size(); ++i) {</div>
<div class="line">        <span class="keywordflow">if</span>(i &gt; 0)</div>
<div class="line">            os &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">        os &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; v[i].first &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; v[i].second &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> os &lt;&lt; <span class="stringliteral">&quot;}&quot;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    NautyParameters params{</div>
<div class="line">        .connected=<span class="keyword">true</span>,</div>
<div class="line">        .V=1,</div>
<div class="line">        .Vmax=8,</div>
<div class="line">    };</div>
<div class="line">    Nauty nauty;</div>
<div class="line">    <span class="keyword">auto</span> lower_bounds = nauty.run_async&lt;Callback&gt;(</div>
<div class="line">        params,</div>
<div class="line">        16,     <span class="comment">// 16 workers (or threads)</span></div>
<div class="line">        10&#39;000  <span class="comment">// 10k graphs per buffer</span></div>
<div class="line">    );</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; [degdist, alpha] : lower_bounds)</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;alpha(G) &gt;= &quot;</span> &lt;&lt; alpha &lt;&lt; <span class="stringliteral">&quot; if degdist(G) is &quot;</span> &lt;&lt; degdist &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="anamespacenautypp_html"><div class="ttname"><a href="namespacenautypp.html">nautypp</a></div><div class="ttdoc">Namespace containing everything related to the wrapper.</div><div class="ttdef"><b>Definition:</b> nauty.hpp:32</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4e2c9112df331005c491c0d68d9404a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2c9112df331005c491c0d68d9404a5">&#9670;&nbsp;</a></span>run_async() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;GraphFunctionType GraphFunction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nautypp::Nauty::run_async </td>
          <td>(</td>
          <td class="paramtype">GraphFunction&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnautypp_1_1NautyParameters.html">NautyParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nb_workers</em> = <code>std::thread::hardware_concurrency()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>worker_buffer_size</em> = <code>5'000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run some callback on all graphs generated by geng/gentreeg. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The function to execute on every graph. </td></tr>
    <tr><td class="paramname">nb_workers</td><td>The number of threads to create to dispatch the generated graphs. </td></tr>
    <tr><td class="paramname">worker_buffer_size</td><td>The buffer size for every worker.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;atomic&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;nautypp/nautypp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacenautypp.html">nautypp</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> constexpr <span class="keywordtype">int</span> V{6};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> contains_triangle(<span class="keyword">const</span> Graph&amp; G) {</div>
<div class="line">    std::vector&lt;bool&gt; marked(G.V(), <span class="keyword">false</span>);</div>
<div class="line">    std::vector&lt;std::pair&lt;Vertex, Vertex&gt;&gt; stack;</div>
<div class="line">    stack.emplace_back(0, -1);</div>
<div class="line">    <span class="keywordflow">while</span>(not stack.empty()) {</div>
<div class="line">        <span class="keyword">auto</span> [v, parent] = stack.back();</div>
<div class="line">        stack.pop_back();</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keyword">auto</span> w : G.neighbours_of(v)) {</div>
<div class="line">            <span class="keywordflow">if</span>(marked[w]) {</div>
<div class="line">                <span class="keywordflow">if</span>(G.are_linked(parent, w))</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">                <span class="keywordflow">continue</span>;</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                marked[w] = <span class="keyword">true</span>;</div>
<div class="line">                stack.emplace_back(w, v);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">unsigned</span> through_all() {</div>
<div class="line">    NautyParameters params{</div>
<div class="line">        .tree=<span class="keyword">false</span>,</div>
<div class="line">        .connected=<span class="keyword">true</span>,</div>
<div class="line">        .triangle_free=<span class="keyword">false</span>,</div>
<div class="line">        .V=V,</div>
<div class="line">        .Vmax=V</div>
<div class="line">    };</div>
<div class="line">    Nauty nauty;</div>
<div class="line">    std::atomic_uint ret;</div>
<div class="line">    nauty.run_async(</div>
<div class="line">        [&amp;ret](<span class="keyword">const</span> Graph&amp; G) {</div>
<div class="line">            <span class="keywordflow">if</span>(contains_triangle(G))</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            ++ret;</div>
<div class="line">        },</div>
<div class="line">        params</div>
<div class="line">    );</div>
<div class="line">    <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">unsigned</span> through_triangle_frees() {</div>
<div class="line">    NautyParameters params{</div>
<div class="line">        .tree=<span class="keyword">false</span>,</div>
<div class="line">        .connected=<span class="keyword">true</span>,</div>
<div class="line">        .triangle_free=<span class="keyword">true</span>,</div>
<div class="line">        .V=V,</div>
<div class="line">        .Vmax=V</div>
<div class="line">    };</div>
<div class="line">    Nauty nauty;</div>
<div class="line">    std::atomic_uint ret;</div>
<div class="line">    nauty.run_async(</div>
<div class="line">        [&amp;ret](<span class="keyword">const</span> Graph&amp; <span class="comment">/* G */</span>) {</div>
<div class="line">            ++ret;</div>
<div class="line">        },</div>
<div class="line">        params</div>
<div class="line">    );</div>
<div class="line">    <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keywordtype">unsigned</span> first_count{through_all()};</div>
<div class="line">    <span class="keywordtype">unsigned</span> second_count{through_triangle_frees()};</div>
<div class="line">    <span class="keywordflow">if</span>(first_count != second_count) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Problem: counted &quot;</span> &lt;&lt; first_count &lt;&lt; <span class="stringliteral">&quot; and then &quot;</span> &lt;&lt; second_count &lt;&lt; std::endl;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        std::cout&lt;&lt; <span class="stringliteral">&quot;OK: &quot;</span> &lt;&lt; first_count &lt;&lt; <span class="stringliteral">&quot; == &quot;</span> &lt;&lt; second_count &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="adffe78c2e8d9d11ffdcbfd475e6a3240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adffe78c2e8d9d11ffdcbfd475e6a3240">&#9670;&nbsp;</a></span>run_async() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;GraphFunctionType GraphFunction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nautypp::Nauty::run_async </td>
          <td>(</td>
          <td class="paramtype">GraphFunction&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_graph_size</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nb_workers</em> = <code>std::thread::hardware_concurrency()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>worker_buffer_size</em> = <code>5'000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run some callback on all graphs found in a file. </p>
<p>The file must contain graphs either in the format graph6 or sparse6.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The function to execute on every graph. </td></tr>
    <tr><td class="paramname">file_path</td><td>The path to the file containing the graphs. </td></tr>
    <tr><td class="paramname">max_graph_size</td><td>The maximal order of a graph in the file. </td></tr>
    <tr><td class="paramname">nb_workers</td><td>The number of threads to create to dispatch the generated graphs. </td></tr>
    <tr><td class="paramname">worker_buffer_size</td><td>The buffer size for every worker.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;nautypp/nautypp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacenautypp.html">nautypp</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> constexpr <span class="keywordtype">char</span> <span class="keyword">const</span> *  file_path{<span class="stringliteral">&quot;tmp.txt&quot;</span>};</div>
<div class="line"><span class="keyword">static</span> constexpr <span class="keywordtype">char</span> <span class="keyword">const</span> *  cmd{<span class="stringliteral">&quot;geng -t&quot;</span>};</div>
<div class="line"><span class="keyword">static</span> constexpr <span class="keywordtype">size_t</span>        nb_vertices{5};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> init_file() {</div>
<div class="line">    std::stringstream ss;</div>
<div class="line">    ss &lt;&lt; cmd &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; nb_vertices &lt;&lt; <span class="stringliteral">&quot; -q &quot;</span> &lt;&lt; file_path;</div>
<div class="line">    std::system(ss.str().c_str());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> remove_file() {</div>
<div class="line">    std::remove(file_path);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">std::vector&lt;Vertex&gt; common_neighbours(<span class="keyword">const</span> Graph&amp; G, Vertex v, Vertex w) {</div>
<div class="line">    std::vector&lt;Vertex&gt; ret;</div>
<div class="line">    std::vector&lt;Vertex&gt; Nv{G.neighbours_of(v)};</div>
<div class="line">    std::vector&lt;Vertex&gt; Nw{G.neighbours_of(w)};</div>
<div class="line">    std::set_intersection(</div>
<div class="line">        Nv.begin(), Nv.end(),</div>
<div class="line">        Nw.begin(), Nw.end(),</div>
<div class="line">        std::back_inserter(ret)</div>
<div class="line">    );</div>
<div class="line">    <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> contains_triangle(<span class="keyword">const</span> Graph&amp; G) {</div>
<div class="line">    <span class="keywordflow">for</span>(Vertex v{0}; v &lt; G.V(); ++v)</div>
<div class="line">        <span class="keywordflow">for</span>(Vertex w : G.neighbours_of(v))</div>
<div class="line">            <span class="keywordflow">if</span>(common_neighbours(G, v, w).size() &gt; 0)</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    init_file();</div>
<div class="line">    Nauty nauty;</div>
<div class="line">    std::atomic_bool found_triangle{<span class="keyword">false</span>};</div>
<div class="line">    nauty.run_async(</div>
<div class="line">        [&amp;found_triangle](<span class="keyword">const</span> Graph&amp; G) {</div>
<div class="line">            <span class="keywordflow">if</span>(contains_triangle(G)) {</div>
<div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot;Found a triangle\n&quot;</span>;</div>
<div class="line">                found_triangle = <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">        },</div>
<div class="line">        file_path,</div>
<div class="line">        nb_vertices</div>
<div class="line">    );</div>
<div class="line">    remove_file();</div>
<div class="line">    <span class="keywordflow">if</span>(not found_triangle)</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;All good!\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5c8e134437462fe28e3c688f9e0af163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8e134437462fe28e3c688f9e0af163">&#9670;&nbsp;</a></span>run_async() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;GraphFunctionType GraphFunction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nautypp::Nauty::run_async </td>
          <td>(</td>
          <td class="paramtype">GraphFunction&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_graph_size</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nb_workers</em> = <code>std::thread::hardware_concurrency()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>worker_buffer_size</em> = <code>5'000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run some callback on all graphs found in a file. </p>
<p>The file must contain graphs either in the format graph6 or sparse6. The file is not closed after reading. Unless you explicitely need to hand the file on your own, prefer the version requiring the path to the file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The function to execute on every graph. </td></tr>
    <tr><td class="paramname">f</td><td>The the file containing the graphs. </td></tr>
    <tr><td class="paramname">max_graph_size</td><td>The maximal order of a graph in the file. </td></tr>
    <tr><td class="paramname">nb_workers</td><td>The number of threads to create to dispatch the generated graphs. </td></tr>
    <tr><td class="paramname">worker_buffer_size</td><td>The buffer size for every worker.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;nautypp/nautypp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacenautypp.html">nautypp</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> constexpr <span class="keywordtype">char</span> <span class="keyword">const</span> *  file_path{<span class="stringliteral">&quot;tmp.txt&quot;</span>};</div>
<div class="line"><span class="keyword">static</span> constexpr <span class="keywordtype">char</span> <span class="keyword">const</span> *  cmd{<span class="stringliteral">&quot;geng -t&quot;</span>};</div>
<div class="line"><span class="keyword">static</span> constexpr <span class="keywordtype">size_t</span>        nb_vertices{5};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> init_file() {</div>
<div class="line">    std::stringstream ss;</div>
<div class="line">    ss &lt;&lt; cmd &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; nb_vertices &lt;&lt; <span class="stringliteral">&quot; -q &quot;</span> &lt;&lt; file_path;</div>
<div class="line">    std::system(ss.str().c_str());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> remove_file() {</div>
<div class="line">    std::remove(file_path);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">std::vector&lt;Vertex&gt; common_neighbours(<span class="keyword">const</span> Graph&amp; G, Vertex v, Vertex w) {</div>
<div class="line">    std::vector&lt;Vertex&gt; ret;</div>
<div class="line">    std::vector&lt;Vertex&gt; Nv{G.neighbours_of(v)};</div>
<div class="line">    std::vector&lt;Vertex&gt; Nw{G.neighbours_of(w)};</div>
<div class="line">    std::set_intersection(</div>
<div class="line">        Nv.begin(), Nv.end(),</div>
<div class="line">        Nw.begin(), Nw.end(),</div>
<div class="line">        std::back_inserter(ret)</div>
<div class="line">    );</div>
<div class="line">    <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> contains_triangle(<span class="keyword">const</span> Graph&amp; G) {</div>
<div class="line">    <span class="keywordflow">for</span>(Vertex v{0}; v &lt; G.V(); ++v)</div>
<div class="line">        <span class="keywordflow">for</span>(Vertex w : G.neighbours_of(v))</div>
<div class="line">            <span class="keywordflow">if</span>(common_neighbours(G, v, w).size() &gt; 0)</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    init_file();</div>
<div class="line">    Nauty nauty;</div>
<div class="line">    std::atomic_bool found_triangle{<span class="keyword">false</span>};</div>
<div class="line">    nauty.run_async(</div>
<div class="line">        [&amp;found_triangle](<span class="keyword">const</span> Graph&amp; G) {</div>
<div class="line">            <span class="keywordflow">if</span>(contains_triangle(G)) {</div>
<div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot;Found a triangle\n&quot;</span>;</div>
<div class="line">                found_triangle = <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">        },</div>
<div class="line">        file_path,</div>
<div class="line">        nb_vertices</div>
<div class="line">    );</div>
<div class="line">    remove_file();</div>
<div class="line">    <span class="keywordflow">if</span>(not found_triangle)</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;All good!\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>includes/nautypp/<a class="el" href="nauty_8hpp_source.html">nauty.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
