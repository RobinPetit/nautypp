#include <iostream>
#include <map>

#include <nautypp/nautypp>

using namespace nautypp;

static void _max_independent_set(
        const Graph& G, std::vector<std::uint8_t>& taken,
        size_t& current_size, size_t& max_size, Vertex v) {
    if(v == G.V()) {
        if(current_size > max_size)
            max_size = current_size;
    } else {
        bool can_take_v{true};
        for(Vertex w : G.neighbours_of(v)) {
            if(taken[w]) {
                can_take_v = false;
                break;
            }
        }
        if(can_take_v) {
            taken[v] = true;
            ++current_size;
            _max_independent_set(G, taken, current_size, max_size, v+1);
            --current_size;
            taken[v] = false;
        }
        _max_independent_set(G, taken, current_size, max_size, v+1);
    }
}
// Compute the independence number of a graph
static inline size_t max_independent_set(const Graph& G) {
    std::vector<std::uint8_t> taken(G.V(), false);
    size_t current_size{0};
    size_t max_size{0};
    _max_independent_set(G, taken, current_size, max_size, 0);
    return max_size;
}

struct Callback {
    typedef std::map<Graph::DegreeDistribution, size_t> ResultType;

    // Called on each graph generated by geng
    void operator()(Graph& G) {
        size_t alpha{max_independent_set(G)};
        auto degdist{G.degree_distribution()};
        auto [it, inserted] = minima.try_emplace(std::move(degdist), alpha);
        // only keep the smallest independence number associated with this degree distribution
        if(not inserted and alpha < it->second)
            it->second = alpha;
    }

    // When every worker thread is done with its computations,
    // they are joined through this method
    void join(Callback&& other) {
        minima.merge(other.minima);
        for(auto& [degdist, alpha] : other.minima) {
            auto it{minima.find(degdist)};
            it->second = std::min(it->second, alpha);
        }
    }

    // And once all the workers are joined, the final result is pooled from the last one
    ResultType&& get() {
        return std::move(minima);
    }

private:
    ResultType minima;
};

std::ostream& operator<<(std::ostream& os, const std::vector<std::pair<size_t, size_t>>& v) {
    os << "{";
    for(size_t i{0}; i < v.size(); ++i) {
        if(i > 0)
            os << ", ";
        os << "(" << v[i].first << ", " << v[i].second << ")";
    }
    return os << "}";
}

int main() {
    NautyParameters params{
        .connected=true,
        .V=1,
        .Vmax=8,
    };
    Nauty nauty(params);
    auto lower_bounds = nauty.run_async<Callback>(
        16,     // 16 workers (or threads)
        10'000  // 10k graphs per buffer
    );
    for(auto& [degdist, alpha] : lower_bounds)
        std::cout << "alpha(G) >= " << alpha << " if degdist(G) is " << degdist << std::endl;
}
